# coding: utf-8

"""
QueryApi.py
Copyright 2016 SmartBear Software

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
"""

from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class QueryApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def create_query(self, **kwargs):
        """
        create query
        ### Create a query.  This allows you to create a new query that you can later run. Looker queries are immutable once created and are not deleted. If you create a query that is exactly like an existing query then the existing query will be returned and no new query will be created. Whether a new query is created or not, you can use the 'id' in the returned query with the 'run' method.  The query parameters are passed as json in the body of the request.  

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_query(callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Query body: query
        :return: Query
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_query" % key
                )
            params[key] = val
        del params['kwargs']



        resource_path = '/queries'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Query',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def create_query_and_run_async(self, body, **kwargs):
        """
        Create a Query and run it asynchronously.
        Given a set of properties for a Query, fetches or creates the Query and starts running it asynchronously. The Query Task results endpoint can be used to fetch the query. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.create_query_and_run_async(body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param Query body: Query data (required)
        :param str format: Format of the response. Default is json.
        :return: AsyncQuery
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'format']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_query_and_run_async" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_query_and_run_async`")


        resource_path = '/queries/run_async'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'format' in params:
            query_params['format'] = params['format']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='AsyncQuery',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def query(self, query_id, **kwargs):
        """
        get query
        ### Get a previously created query by id.  A Looker query object includes the various parameters that define a database query that has been run or could be run in the future. These parameters include: model, view, fields, filters, pivots, etc. Query *results* are not part of the query object.  Query objects are unique and immutable. Query objects are created automatically in Looker as users explore data. Looker does not delete them; they become part of the query history. When asked to create a query for any given set of parameters, Looker will first try to find an existing query object with matching parameters and will only create a new object when an appropriate object can not be found.  This 'get' method is used to get the details about a query for a given id. See the other methods here to 'create' and 'run' queries.  Note that some fields like 'filter_config' and 'vis_config' etc are specific to how the Looker UI builds queries and visualizations and are not generally useful for API use. They are not required when creating new queries and can usually just be ignored.  

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.query(query_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int query_id: Id of query (required)
        :param str fields: Requested fields.
        :return: Query
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'fields']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_id' is set
        if ('query_id' not in params) or (params['query_id'] is None):
            raise ValueError("Missing the required parameter `query_id` when calling `query`")


        resource_path = '/queries/{query_id}'.replace('{format}', 'json')
        path_params = {}
        if 'query_id' in params:
            path_params['query_id'] = params['query_id']

        query_params = {}
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Query',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def query_for_slug(self, slug, **kwargs):
        """
        get query for slug
        ### Get the query for a given query slug.  This returns the query for the 'slug' in a query share URL.  The 'slug' is a randomly chosen short string that is used as an alternative to the query's id value for use in URLs etc. This method exists as a convenience to help you use the API to 'find' queries that have been created using the Looker UI.  You can use the Looker explore page to build a query and then choose the 'Share' option to show the share url for the query. Share urls generally look something like 'https://looker.yourcompany/x/vwGSbfc'. The trailing 'vwGSbfc' is the share slug. You can pass that string to this api method to get details about the query. Those details include the 'id' that you can use to run the query. Or, you can copy the query body (perhaps with your own modification) and use that as the basis to make/run new queries.  

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.query_for_slug(slug, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str slug: Slug of query (required)
        :param str fields: Requested fields.
        :return: Query
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['slug', 'fields']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_for_slug" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'slug' is set
        if ('slug' not in params) or (params['slug'] is None):
            raise ValueError("Missing the required parameter `slug` when calling `query_for_slug`")


        resource_path = '/queries/slug/{slug}'.replace('{format}', 'json')
        path_params = {}
        if 'slug' in params:
            path_params['slug'] = params['slug']

        query_params = {}
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='Query',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def query_task(self, query_task_id, **kwargs):
        """
        Get a Query Task
        Fetch a Query Task.  Query Tasks are generated by running queries asynchronously. They are represented by a GUID returned from one of the async query endpoints. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.query_task(query_task_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_task_id: ID of the Query Task (required)
        :param str fields: Requested fields.
        :return: RunningQueries
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_task_id', 'fields']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_task" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_task_id' is set
        if ('query_task_id' not in params) or (params['query_task_id'] is None):
            raise ValueError("Missing the required parameter `query_task_id` when calling `query_task`")


        resource_path = '/query_tasks/{query_task_id}'.replace('{format}', 'json')
        path_params = {}
        if 'query_task_id' in params:
            path_params['query_task_id'] = params['query_task_id']

        query_params = {}
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='RunningQueries',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def query_task_multi_results(self, query_task_ids, **kwargs):
        """
        Get multiple query task results in one request.
        Fetch a multiple Query Task results at once. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.query_task_multi_results(query_task_ids, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param list[str] query_task_ids: List of Query Task IDs (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_task_ids']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_task_multi_results" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_task_ids' is set
        if ('query_task_ids' not in params) or (params['query_task_ids'] is None):
            raise ValueError("Missing the required parameter `query_task_ids` when calling `query_task_multi_results`")


        resource_path = '/query_tasks/multi_results'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'query_task_ids' in params:
            query_params['query_task_ids[]'] = params['query_task_ids']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def query_task_results(self, query_task_id, **kwargs):
        """
        Get a Query Task's results
        Fetch a Query Task's results. 

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.query_task_results(query_task_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str query_task_id: ID of the Query Task (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_task_id']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_task_results" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_task_id' is set
        if ('query_task_id' not in params) or (params['query_task_id'] is None):
            raise ValueError("Missing the required parameter `query_task_id` when calling `query_task_results`")


        resource_path = '/query_tasks/{query_task_id}/results'.replace('{format}', 'json')
        path_params = {}
        if 'query_task_id' in params:
            path_params['query_task_id'] = params['query_task_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text', 'application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def run_async(self, query_id, **kwargs):
        """
        Run a Query asynchronously.
        ### Run a saved query asynchronously.  Runs a previously created query asynchronously. Returns a Query Task ID which can be used to fetch the results from the Query Tasks results endpoint.  

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.run_async(query_id, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int query_id: ID of query (required)
        :param AsyncQuery body: async query run
        :return: AsyncQuery
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'body']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_async" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_id' is set
        if ('query_id' not in params) or (params['query_id'] is None):
            raise ValueError("Missing the required parameter `query_id` when calling `run_async`")


        resource_path = '/queries/{query_id}/run_async'.replace('{format}', 'json')
        path_params = {}
        if 'query_id' in params:
            path_params['query_id'] = params['query_id']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='AsyncQuery',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def run_inline_query(self, format, body, **kwargs):
        """
        run inline query
        ### Run the query that is specified inline in the posted body.  This allows running a query as defined in json in the posted body. This combines the two actions of posting & running a query into one step.  Here is an example body in json: ``` {   "model":"thelook",   "view":"inventory_items",   "fields":["category.name","inventory_items.days_in_inventory_tier","products.count"],   "filters":{"category.name":"socks"},   "sorts":["products.count desc 0"],   "limit":"500",   "query_timezone":"America/Los_Angeles" } ```  When using the Ruby SDK this would be passed as a Ruby hash like: ``` {  :model=>"thelook",  :view=>"inventory_items",  :fields=>   ["category.name",    "inventory_items.days_in_inventory_tier",    "products.count"],  :filters=>{:"category.name"=>"socks"},  :sorts=>["products.count desc 0"],  :limit=>"500",  :query_timezone=>"America/Los_Angeles", } ```  This will return the result of running the query in the format specified by the 'format' paramater.  Suported formats: - json - plain json - csv - comma separated values with a header - txt - tab separated values with a header - html - simple html - md - simple markdown - sql - shows the generated SQL rather than running the query - png - a PNG image of the visualization of the query - jpg - a JPG image of the visualization of the query - unified - json that is annotated with additional metadata as used by the Looker web application   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.run_inline_query(format, body, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str format: Format of result (required)
        :param Query body: inline query (required)
        :param int limit: Row limit (may override the limit in the saved query).
        :param bool apply_formatting: Apply model-specified formatting to each result.
        :param bool cache: Get results from cache if available.
        :param int image_width: Render width for image formats.
        :param int image_height: Render height for image formats.
        :param bool generate_drill_links: Generate drill links (only applicable to 'unified' format.
        :param bool force_production: Force use of production models even if the user is in developer mode.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['format', 'body', 'limit', 'apply_formatting', 'cache', 'image_width', 'image_height', 'generate_drill_links', 'force_production']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_inline_query" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'format' is set
        if ('format' not in params) or (params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `run_inline_query`")
        # verify the required parameter 'body' is set
        if ('body' not in params) or (params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `run_inline_query`")


        resource_path = '/queries/run/{format}'.replace('{format}', 'json')
        path_params = {}
        if 'format' in params:
            path_params['format'] = params['format']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'apply_formatting' in params:
            query_params['apply_formatting'] = params['apply_formatting']
        if 'cache' in params:
            query_params['cache'] = params['cache']
        if 'image_width' in params:
            query_params['image_width'] = params['image_width']
        if 'image_height' in params:
            query_params['image_height'] = params['image_height']
        if 'generate_drill_links' in params:
            query_params['generate_drill_links'] = params['generate_drill_links']
        if 'force_production' in params:
            query_params['force_production'] = params['force_production']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text', 'application/json', 'image/png', 'image/jpg'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'POST',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def run_query(self, query_id, format, **kwargs):
        """
        run query
        ### Run a saved query.  This runs a previously saved query. You can use this on a query that was generated in the Looker UI or one that you have explicitly created using the API. You can also use a query 'id' from a saved 'Look'.  This will return the result of running the query in the format specified by the 'format' paramater.  Suported formats: - json - plain json - csv - comma separated values with a header - txt - tab separated values with a header - html - simple html - md - simple markdown - sql - shows the generated SQL rather than running the query - png - a PNG image of the visualization of the query - jpg - a JPG image of the visualization of the query - unified - json that is annotated with additional metadata as used by the Looker web application   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.run_query(query_id, format, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int query_id: Id of query (required)
        :param str format: Format of result (required)
        :param int limit: Row limit (may override the limit in the saved query).
        :param bool apply_formatting: Apply model-specified formatting to each result.
        :param bool cache: Get results from cache if available.
        :param int image_width: Render width for image formats.
        :param int image_height: Render height for image formats.
        :param bool generate_drill_links: Generate drill links (only applicable to 'unified' format.
        :param bool force_production: Force use of production models even if the user is in developer mode.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query_id', 'format', 'limit', 'apply_formatting', 'cache', 'image_width', 'image_height', 'generate_drill_links', 'force_production']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_query" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'query_id' is set
        if ('query_id' not in params) or (params['query_id'] is None):
            raise ValueError("Missing the required parameter `query_id` when calling `run_query`")
        # verify the required parameter 'format' is set
        if ('format' not in params) or (params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `run_query`")


        resource_path = '/queries/{query_id}/run/{format}'.replace('{format}', 'json')
        path_params = {}
        if 'query_id' in params:
            path_params['query_id'] = params['query_id']
        if 'format' in params:
            path_params['format'] = params['format']

        query_params = {}
        if 'limit' in params:
            query_params['limit'] = params['limit']
        if 'apply_formatting' in params:
            query_params['apply_formatting'] = params['apply_formatting']
        if 'cache' in params:
            query_params['cache'] = params['cache']
        if 'image_width' in params:
            query_params['image_width'] = params['image_width']
        if 'image_height' in params:
            query_params['image_height'] = params['image_height']
        if 'generate_drill_links' in params:
            query_params['generate_drill_links'] = params['generate_drill_links']
        if 'force_production' in params:
            query_params['force_production'] = params['force_production']

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text', 'application/json', 'image/png', 'image/jpg'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response

    def run_url_encoded_query(self, model_name, view_name, format, **kwargs):
        """
        run url encoded query
        ### Run an URL encoded query.  This requires the caller to encode the specifiers for the query into the URL query part using Looker-specific syntax as explained below.  Generally, you would want to use one of the methods that takes the parameters as json in the POST body for creating and/or running queries. This method exists for cases where one really needs to encode the paramaters into the URL of a single 'GET' request. This matches the way that the Looker UI formats 'explore' URLs etc.  The parameters here are very similar to the json body formatting except that the filter syntax is tricky. Unfortunately, this format makes this method not currently callible via the 'Try it out!' button in this documentation page. But, this is callable  when creating URLs manually or when using the Looker SDK.  Here is an example inline query URL:  "https://looker.mycompany.com:19999/api/3.0/queries/models/thelook/views/inventory_items/run/json?fields=category.name,inventory_items.days_in_inventory_tier,products.count&f[category.name]=socks&sorts=products.count+desc+0&limit=500&query_timezone=America/Los_Angeles"  When calling the Ruby SDK, one passes the query parameter parts as a hash. The hash to match the above would like like:  ``` {   :fields => "category.name,inventory_items.days_in_inventory_tier,products.count",   :"f[category.name]" => "socks",   :sorts => "products.count desc 0",   :limit => "500",   :query_timezone => "America/Los_Angeles" } ```  Again, it is generally easier to use the variant of this method that passes the full query in the POST body. This method is available for cases where other alternatives won't fit the need.  Suported formats: - json - plain json - csv - comma separated values with a header - txt - tab separated values with a header - html - simple html - md - simple markdown - sql - shows the generated SQL rather than running the query - png - a PNG image of the visualization of the query - jpg - a JPG image of the visualization of the query - unified - json that is annotated with additional metadata as used by the Looker web application   

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.run_url_encoded_query(model_name, view_name, format, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str model_name: Model name (required)
        :param str view_name: View name (required)
        :param str format: Format of result (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_name', 'view_name', 'format']
        all_params.append('callback')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method run_url_encoded_query" % key
                )
            params[key] = val
        del params['kwargs']

        # verify the required parameter 'model_name' is set
        if ('model_name' not in params) or (params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `run_url_encoded_query`")
        # verify the required parameter 'view_name' is set
        if ('view_name' not in params) or (params['view_name'] is None):
            raise ValueError("Missing the required parameter `view_name` when calling `run_url_encoded_query`")
        # verify the required parameter 'format' is set
        if ('format' not in params) or (params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `run_url_encoded_query`")


        resource_path = '/queries/models/{model_name}/views/{view_name}/run/{format}'.replace('{format}', 'json')
        path_params = {}
        if 'model_name' in params:
            path_params['model_name'] = params['model_name']
        if 'view_name' in params:
            path_params['view_name'] = params['view_name']
        if 'format' in params:
            path_params['format'] = params['format']

        query_params = {}

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None

        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['text', 'application/json', 'image/png', 'image/jpg'])
        if not header_params['Accept']:
            del header_params['Accept']

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = []

        response = self.api_client.call_api(resource_path, 'GET',
                                            path_params,
                                            query_params,
                                            header_params,
                                            body=body_params,
                                            post_params=form_params,
                                            files=local_var_files,
                                            response_type='str',
                                            auth_settings=auth_settings,
                                            callback=params.get('callback'))
        return response
